\chapter{Analysis}
\label{chapter:analysis}

In the Prior Work \autoref{cha:prior-work}, we discussed how the project started as a decentralized
storage system with verification and then evolved into integrating PoR into the verification,
as soon as limitations of the decentralized verification mechanism were discovered.
In this chapter we will discuss how we are solving the problem of storage attacks
and how does PoR integrate into the reputation system.
It is worth noting that apart from malicious peers, it is also possible for well-behaved peers to
lose data due to hardware failures (bit rot).
We will not cover this case as a special case, because it is a light version of what malicious
peers are capable of doing.

\section{Malicious peers}

There could be many types of malicious peers in a decentralized network,
but we will cover only the relevant ones for the scope of the project.
The Related Work \autoref{chapter:related-work} covers other systems and
how they handle the other types of attacks, not covered here.

There are two types of attacks that can affect the integrity of the data in the network:
\begin{enumerate}
    \item \textbf{Data availability attacks} --- an attacker claims to store data, but does not.
    \item \textbf{Data integrity attacks} --- an attacker claims to store data, but stores different data.
\end{enumerate}

While the two seem similar, we will cover them separately, because they are performed by different types of attackers
and the detection mechanisms are different.
We would like to investigate the different behaviors of peers and how to deal with them.
How severe should the punishment for each type of attack be?

\textbf{Data availability attacks} could be performed by the following peer behaviors:
\begin{enumerate}
    \item \textbf{Not storing the data} --- the peer does not store the data at all.
    \item \textbf{Peer goes offline permanently} --- the peer goes offline at some point in the future after accepting to store the data.
    \item \textbf{Peer goes offline temporarily} --- the peer goes offline for a short period of time.
        This could be a peer that is restarting or lost connection to the network.
        This is not necessarily a malicious peer, but it should be accounted for,
        because malicious peers could be performing an eclipse attack.
    \item \textbf{The peer is slow to respond} --- the peer is slow to respond to requests.
        This could happen when a peer is overloaded or has a slow connection.
        It could also be a malicious peer that is not storing the data and tries to request it
        from another peer in the network, before answering the request.
\end{enumerate}

\textbf{Data integrity attacks} could be performed by the following peer behaviors:
\begin{enumerate}
    \item \textbf{Storing corrupted data} --- the peer stores corrupted data.
        It could be that the peer is trying to save space by storing partial data.
        Or perhaps the peer is trying to simply disrupt the network.
    \item \textbf{Storing corrupted metadata} --- the peer stores the correct data, but the metadata is corrupted.
        This could mean storing the wrong expiry date or the wrong key.
        This kind of behavior either wouldn't affect the operation of the network or it would fall
        under the other types of behaviors.
\end{enumerate}

The impact of all of these behaviors on the network is always dependent on the time it takes to detect them.
If the time to verify a piece of data is too long, a malicious peer could delete it and then
request it from another peer in the network just before the audit.
Thereby passing the audit, but not contributing to the network.
This is one of the reasons that it is a key requirement to have fast verification mechanisms.
While this is a possible attack, it is an expensive one to execute,
because the attacker needs to perform a lot of work to pass the audit.
The attacker also needs to contribute considerable amount of their bandwidth to execute such an attack.
For the above reasons, we will not consider this attack in our analysis.

\section{Using Proof of Retrievability (PoR) to prevent attacks}

Preventing a Data availability attack can be done by querying the peer whether it has the data.
In this case we assume that the peer is honest and will return a simple answer whether it has the data or not.
The assumption that a peer will be honest is naive, but allows us to easily check if the peer is responsive.
One of the reasons we want to separate this attack is, so we can analyze peers going offline separately.
We will discuss how to handle temporary and permanent offline peers in the evaluation section.
\wtf{maybe it shouldn't be in the evaluation section, I just want to say we need to look at data
before we can say how to handle it.}

Preventing a Data integrity attack can be done by requesting the peer to return the data and checking if
the data is correct.
This is a more complex operation, because the data could be large, and the network could be slow.
This is a stronger requirement for the network, because peers performing this attack are a superset
of the peers performing the data availability attack.

In order to address data integrity attacks, we make use of Proof of Retrievability (PoR).
PoR is a cryptographic protocol that allows a peer to prove to a verifier that it is storing a file.
The verifier does not need to know the file, but only a small secret that is generated from the file.
The verifier can then challenge the peer to prove that it is storing the file by sending a challenge and
comparing the response to an expected response.
Both the challenge and the response are small.
The exact size depends on the PoR protocol used, and in our case is $O(\sqrt{N})$ \cite{poralgebra} for
both the challenge and the response, where $N$ is the size of the file in bytes.

Since the PoR protocol is cheap to execute both on the network and on the computation side of the verifier,
it can be used to address both types of attacks.

\section{Reputation system}

To keep track of the behavior of the peers in the network, we will use a reputation system.
In short, we want well-behaved peers to have a high reputation and malicious peers to have a low reputation.
Peers with higher reputation will be prioritized by the network, while peers with lower reputation will be
avoided and potentially removed from the network.
A key part of designing the reputation system is defining how much reputation is adjusted in each case.
First, we will look into what situations lead to reputation adjustment, and then we will
analyze how much reputation should be adjusted in each case.

Reputation will be increased when a peer is behaving as expected,
i.e., storing data and providing data, as well as performing audits will lead to an increase in reputation.

Reputation should be decreased in the case of failure to comply with the network rules.
A peer that is not storing data should have their reputation reduced on each audit,
until their reputation is so low that they are not trusted anymore and are removed from the network.
A peer that goes offline permanently would fall under the same category, as it would fail all its audits.
A peer that goes offline temporarily should be punished for the failed audits,
but the punishment should be such that for a short period of being offline the peer should not use 
too much of its reputation.
When a peer is slow to respond to requests, the audit will be considered failed and the peer will have
its reputation reduced as if it was not storing the data.

For the data integrity attacks, and in particular for storing corrupted data,
the punishment should be the same as for the data availability attacks.

The questions we need to answer are:
\begin{enumerate}
    \item How many audits can we perform in parallel?
    \item What is the performance impact of the audits on the network?
    \item How do we balance the punishment so that a peer that has been offline for a short period of time
        is not punished too much?
    \item What is a short period of time to be offline?
    \item Can we make the punishment scale with time? The longer the peer is offline, the more severe the punishment.
    \item What does it mean for a peer to be slow to respond?
\end{enumerate}

We have mostly answered the last question in our previous work, where we have evaluated the performance of
the PoR scheme we have implemented.
To answer the question fully, we also need to account for the network latency.
However, for small enough files, we cannot guarantee that the peer is storing the data
and not just fetching it from another peer in the network.
\wtf{I need to find a way to use this data https://wondernetwork.com/pings/Dagupan/Alblasserdam.
It suggests that the average ping between Dagupan, Philippines to Alblasserdam, Netherlands is
815ms and peak time latency is 1800ms, so we can use 2s as a timeout for the audit.}


...


% The one exception is storage attacks.
% No decentralized network has a solution for storage attacks.

% \subsection{Storage attacks}
% \label{section:storage-attacks}

% Storage attacks are the main focus of this thesis.
% They are mostly ignored by the literature, because decentralized networks are often designed to
% drop old files based on some criteria, such as popularity or age.
% This is done to save space and to keep the network up to date.
% However, if we want durable storage, we need to address these attacks.

% Storage attacks can be classified into two categories:
% \begin{enumerate}
%     \item \textbf{Data availability attacks} --- an attacker claims to store data, but does not.
%     \item \textbf{Data integrity attacks} --- an attacker claims to store data, but stores different data.
% \end{enumerate}

% Checking if a node stores the data it claims to store can be as simple as asking the node to return the data.
% However, this is a very inefficient and bandwidth-consuming method.
% Ideally, we would like to reduce the amount of traffic between nodes and still be able to check
% if the data is stored correctly.

Notes \wtf{format this explanation at the beginning of the chapter - explaining how the reputation system works}

Filecoin uses the coin as payments, we want to use the coin as a stake.
The coin indicates reputation, not wealth.
We want to trade storage for storage, not storage for money.
i.e., using coins to trade trust/credibility, not work done.
Filecoin makes the assumption that PoR protocols do not check the whole file,
which is not true in the protocols we are looking at.
Filecoin also mentions two types of new attacks:
Sybil attack, where the malicious peers create multiple identities but store the same data in 1 place.
And Outsourcing attacks --- malicious peers claim to be able to store more data than they actually can,
by storing the data elsewhere (e.g., in the network) and rely on quickly fetching it when requested.
Maybe we can use timeouts for the audits to prevent this --- because PoR should be very fast (no network delay).
Proof of Spacetime can be used as well --- require the server to run PoR every X time and then use some form Of
chained hashes or signatures to collect all the proofs and verify them in a single audit (not sure If
this works with the current PoR protocols, but it's an idea).
